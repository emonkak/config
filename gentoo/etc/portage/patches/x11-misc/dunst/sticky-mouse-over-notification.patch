diff --git a/src/dbus.c b/src/dbus.c
index 3b84615..95a9012 100644
--- a/src/dbus.c
+++ b/src/dbus.c
@@ -704,7 +704,9 @@ static void dbus_cb_CloseNotification(
                                 signal_notification_closed(n, REASON_SIG);
                 }
         } else {
-                queues_notification_close_id(id, REASON_SIG);
+                struct notification *n = queues_get_by_id(id);
+                if (n)
+                        n->closed_by_signal = true;
         }
         wake_up();
         g_dbus_method_invocation_return_value(invocation, NULL);
diff --git a/src/notification.h b/src/notification.h
index 4627808..88c4967 100644
--- a/src/notification.h
+++ b/src/notification.h
@@ -100,6 +100,7 @@ struct notification {
         int displayed_height;
         enum behavior_fullscreen fullscreen; //!< The instruction what to do with it, when desktop enters fullscreen
         bool script_run;        /**< Has the script been executed already? */
+        bool closed_by_signal;  /**< has been closed by a signal? */
         guint8 marked_for_closure;
         bool word_wrap;
         PangoEllipsizeMode ellipsize;
diff --git a/src/queues.c b/src/queues.c
index c599161..2d3098a 100644
--- a/src/queues.c
+++ b/src/queues.c
@@ -34,6 +34,8 @@ static GQueue *history   = NULL; /**< history of displayed notifications */
 
 int next_notification_id = 1;
 
+int keep_display = false;
+
 static bool queues_stack_duplicate(struct notification *n);
 static bool queues_stack_by_tag(struct notification *n);
 
@@ -434,10 +436,18 @@ void queues_update(struct dunst_status status, gint64 time)
                 }
 
 
-                if (queues_notification_is_finished(n, status, time)){
-                        queues_notification_close(n, REASON_TIME);
-                        iter = nextiter;
-                        continue;
+                if (!keep_display) {
+                        if (n->closed_by_signal) {
+                                queues_notification_close(n, REASON_SIG);
+                                iter = nextiter;
+                                continue;
+                        }
+
+                        if (queues_notification_is_finished(n, status, time)){
+                                queues_notification_close(n, REASON_TIME);
+                                iter = nextiter;
+                                continue;
+                        }
                 }
 
                 if (!queues_notification_is_ready(n, status, true)) {
@@ -594,5 +604,11 @@ void queues_teardown(void)
         waiting = NULL;
 }
 
+/* see queues.h */
+void queues_keep_display(bool value)
+{
+        keep_display = value;
+}
+
 
 /* vim: set ft=c tabstop=8 shiftwidth=8 expandtab textwidth=0: */
diff --git a/src/x11/x.c b/src/x11/x.c
index 00ae6ff..c2de941 100644
--- a/src/x11/x.c
+++ b/src/x11/x.c
@@ -382,6 +382,14 @@ gboolean x_mainloop_fd_dispatch(GSource *source, GSourceFunc callback, gpointer
                                 win->cur_screen = scr->id;
                         }
                         break;
+                case EnterNotify:
+                        LOG_D("XEvent: processing 'EnterNotify'");
+                        queues_keep_display(true);
+                        break;
+                case LeaveNotify:
+                        LOG_D("XEvent: processing 'LeaveNotify'");
+                        queues_keep_display(false);
+                        break;
                 default:
                         if (!screen_check_event(&ev)) {
                                 LOG_D("XEvent: Ignoring '%d'", ev.type);
@@ -648,7 +656,8 @@ window x_win_create(void)
         wa.colormap = XCreateColormap(xctx.dpy, root, vis, AllocNone);
         wa.event_mask =
             ExposureMask | KeyPressMask | VisibilityChangeMask |
-            ButtonReleaseMask | FocusChangeMask| StructureNotifyMask;
+            ButtonReleaseMask | FocusChangeMask| StructureNotifyMask |
+            EnterWindowMask | LeaveWindowMask;
 
         const struct screen_info *scr = get_active_screen();
         win->xwin = XCreateWindow(xctx.dpy,
